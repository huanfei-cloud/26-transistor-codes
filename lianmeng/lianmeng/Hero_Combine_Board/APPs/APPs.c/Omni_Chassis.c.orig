#include "Omni_Chassis.h"
#include "M2006_Motor.h"
#include "BSP_Can.h"

/***************用户数据定义***************/
void Chassis_open_init(void);
void CHASSIS_InitArgument(void);
void Omni_calc(void);
void Omni_angle_calc(float* out_angle) ;
void Omni_Set_Motor_Speed(M2006s_t* Motor);
void Absolute_Cal(float angle)	;
float Find_Y_AnglePNY(void);
float Find_min_Angle(int16_t angle1,fp32 angle2);
void RemoteControlChassis(int16_t *speed);
void Chassis_Single_Loop_Out(void); 
void Chassis_GetAngle(fp32 angle);

Chassis_Data_t Chassis_Data = Chassis_DataGroundInit;
#undef Chassis_DataGroundInit

/***************输出接口定义***************/
Chassis_Fun_t Chassis_Fun = Chassis_FunGroundInit;
#undef Chassis_FunGroundInit

/**
  * @brief  获取遥控器指令
  * @param  speed为传入底盘的绝对目标速度
  * @retval void
  * @attention 通过遥控器下（串口）发底盘的目标速度
  */
void RemoteControlChassis(int16_t *speed)
{
    Chassis_Data.Speed_ToCloud.vx = speed[0];
    Chassis_Data.Speed_ToCloud.vy = speed[1];
    Chassis_Data.Speed_ToCloud.vw = speed[2];
}

/**
  * @brief  将云台坐标转换为底盘坐标
  * @param  absolute_speed 绝对坐标需要的速度
  * @param  angle 云台相对于底盘的角度
  * @retval 偏差角，角度制
  * @attention 假定给定速度是以云台为坐标系，此函数将给定速度转化到底盘坐标系下
  */
void Absolute_Cal(fp32 angle)
{
    fp32 angle_hd = angle * PI / 180;
	
    Chassis_Data.Speed_ToChassis.vw = Chassis_Data.Speed_ToCloud.vw;
    Chassis_Data.Speed_ToChassis.vx = Chassis_Data.Speed_ToCloud.vx * cos(angle_hd) - \
																			Chassis_Data.Speed_ToCloud.vy * sin(angle_hd);
    Chassis_Data.Speed_ToChassis.vy = Chassis_Data.Speed_ToCloud.vx * sin(angle_hd) + \
																			Chassis_Data.Speed_ToCloud.vy * cos(angle_hd);

    //保证底盘是相对摄像头做移动，当摄像头转过90度时x方向速度从1变0，
    //y方向速度从0变1，保证视觉上是相对右移

    Omni_calc();
}

/**
  * @brief  将底盘坐标下质心的速度分解为四个驱动轮的速度
  * @param  speed为底盘坐标系下质心的速度
  * @param  out_speed为四个轮的输出速度
  * @retval 偏差角，角度制
  * @attention 假定给定速度是以云台为坐标系，此函数将给定速度转化到底盘坐标系下
  */
void Omni_calc()
{
    int16_t wheel_rpm[4];
    float wheel_rpm_ratio;
		//需要将线速度转化为转速rpm
    wheel_rpm_ratio = 60.0f / (WHEEL_PERIMETER * 3.14f) * M2006_ReductionRatio;
	
		/*x，y方向速度,w底盘转动速度*/
    wheel_rpm[0] = ( Chassis_Data.Speed_ToChassis.vx + Chassis_Data.Speed_ToChassis.vy + \
										Chassis_Data.Speed_ToChassis.vw * (LENGTH_A + LENGTH_B)) * wheel_rpm_ratio; //left
    wheel_rpm[1] = ( Chassis_Data.Speed_ToChassis.vx - Chassis_Data.Speed_ToChassis.vy + \
										Chassis_Data.Speed_ToChassis.vw * (LENGTH_A + LENGTH_B)) * wheel_rpm_ratio; //forward
    wheel_rpm[2] = (-Chassis_Data.Speed_ToChassis.vx - Chassis_Data.Speed_ToChassis.vy + \
										Chassis_Data.Speed_ToChassis.vw * (LENGTH_A + LENGTH_B)) * wheel_rpm_ratio; //right
    wheel_rpm[3] = (-Chassis_Data.Speed_ToChassis.vx + Chassis_Data.Speed_ToChassis.vy + \
										Chassis_Data.Speed_ToChassis.vw * (LENGTH_A + LENGTH_B)) * wheel_rpm_ratio; //back

    memcpy(Chassis_Data.M2006_Setspeed, wheel_rpm, sizeof(wheel_rpm)); //copy the rpm to out_speed
}

/**
  * @brief  设置2006目标速度
  * @param  out_speed 目标速度
  * @param  Motor 电机结构体
  * @retval
  * @attention
  */
void Omni_Set_Motor_Speed(M2006s_t *Motor )
{
    Motor[0].targetSpeed = Chassis_Data.M2006_Setspeed[0];
    Motor[1].targetSpeed = Chassis_Data.M2006_Setspeed[1];
    Motor[2].targetSpeed = Chassis_Data.M2006_Setspeed[2];
    Motor[3].targetSpeed = Chassis_Data.M2006_Setspeed[3];
}

/**
  * @brief  底盘电机输出
  * @param  void
  * @retval void
  * @attention
  */
void Chassis_Single_Loop_Out()
{
    uint8_t data[8] = {0};

    Absolute_Cal(Chassis_Data.Angle_ChassisToCloud); //计算各个电机的目标速度
    Omni_Set_Motor_Speed(M2006_Array); 							 //设置各个电机的目标速度

    //Chassis_Power_Limit();//功率限制

    /**************************底盘2006电机速度环计算*****************************/
//		 speed[i] = Wheel_PID[i]->Incremental_PID(Wheel_PID[i], M3508s[i].targetSpeed, M3508s[i].realSpeed);
    M2006_Array[0].outCurrent = Incremental_PID(&M2006_Array_Pid[0], 
																						 M2006_Array[0].targetSpeed, 
																						 M2006_Array[0].realSpeed);
    M2006_Array[1].outCurrent = Incremental_PID(&M2006_Array_Pid[1], 
																						 M2006_Array[1].targetSpeed, 
																						 M2006_Array[1].realSpeed);
		M2006_Array[2].outCurrent = Incremental_PID(&M2006_Array_Pid[2], 
																						 M2006_Array[2].targetSpeed, 
																						 M2006_Array[2].realSpeed);
		M2006_Array[3].outCurrent = Incremental_PID(&M2006_Array_Pid[3], 
																						 M2006_Array[3].targetSpeed, 
																						 M2006_Array[3].realSpeed);

    /***************************将电流参数发送给电机*******************************/
    M2006_FUN.M2006_setCurrent(M2006_Array[0].outCurrent, M2006_Array[1].outCurrent, 
															 M2006_Array[2].outCurrent, M2006_Array[3].outCurrent,
															 data);
    Can_Fun.CAN_SendData(CAN_SendHandle, &hcan1, CAN_ID_STD, M2006_SENDID, data);
}

void Chassis_GetAngle(fp32 angle)
{
	Chassis_Data.Angle_ChassisToCloud = angle * 57.29578f ;
}


