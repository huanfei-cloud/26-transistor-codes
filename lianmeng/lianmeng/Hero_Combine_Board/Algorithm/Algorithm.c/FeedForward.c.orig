/**
 * @file FeedForward.c
 * @author Why
 * @brief 前馈控制,取实测量的百分之八十
 * @version 0.1
 * @date 2023-08-28
 * @attention 一定要在PID算出电流之后再重新引用这个函数，因为是直接加在输出电流上了 
 *
 * @copyright 
 * 
 */

#include "M3508_Motor.h"
#include "M6020_Motor.h"
#include "Cloud_Control.h"
#include "Dial.h"
#include "FeedForward.h"

/**************用户数据定义****************/
void FeedForward_Fric(void);
void FeedForward_Dial(void);
void FeedForward_Yaw_Pitch(void);

/****************接口定义******************/
FeedForward_FUN_t FeedForward_FUN = FeedForward_FunGroundInit;
#undef FeedForward_FunGroundInit

#include "FeedForward.h"

/**
  * @brief   给摩擦轮发送前馈
  * @param   M3508的外部接口
  * @retval  void
  */
void FeedForward_Fric()
{
	/* 平衡摩擦力 */
	if(M3508_Array[FricL_Wheel].realSpeed < 1000)
		M3508_Array[FricL_Wheel].outCurrent += 
			(212 - 0.124f *(float)M3508_Array[FricL_Wheel].realSpeed);
	else
		M3508_Array[FricL_Wheel].outCurrent += 
			(88 - 0.01f * (float)(M3508_Array[FricL_Wheel].realSpeed - 1000));
	
	if(M3508_Array[FricR_Wheel].realSpeed < 1000)
		M3508_Array[FricR_Wheel].outCurrent += 
			(212 - 0.124f * (float)M3508_Array[FricR_Wheel].realSpeed);
	else
		M3508_Array[FricR_Wheel].outCurrent += 
			(88 - 0.01f * (float)(M3508_Array[FricR_Wheel].realSpeed - 1000));
	
	/* 平衡弹丸进摩擦轮的巨大阻力，减少掉速 */
	M3508_Array[FricL_Wheel].outCurrent += 5000;
	M3508_Array[FricR_Wheel].outCurrent += 5000;
}

/**
  * @brief   给拨盘电机发送前馈
  * @param   
  * @retval  void
  * @attention 大弹丸跟小弹丸的参数不一样,所有数字都要改
  */
void FeedForward_Dial()
{
	static uint8_t temp;
	static int16_t temp_v = 0;  // 上一次的速度，用于算加速度
	/* 平衡重力 */
	if(Dial_Data.Bullet_Dialed <= MAX_GRAVITY)
		temp = Dial_Data.Bullet_Dialed;
	else temp = MAX_GRAVITY;
	
	if(temp >= 4) temp -= Num_InTube;
	else temp = 0;
	M3508_Array[Dial_Motor].outCurrent += temp * Gravity_Para;
	
	/* 平衡加速度 */
	if(Dial_Data.Bullet_Dialed <= MAX_GRAVITY)
		temp = Dial_Data.Bullet_Dialed + 6;
	else temp = MAX_GRAVITY + 6;
	M3508_Array[Dial_Motor].outCurrent = temp * (float)(M3508_Array[Dial_Motor].targetSpeed\
										 - temp_v) * Accelerate_Para;
	temp_v = M3508_Array[Dial_Motor].targetSpeed;
	
}

#if Pitch_Fitting == 2
/**
  * @brief   给云台的两个电机发送前馈,pitch用二次函数拟合
  * @param   云台和云台电机的外部接口
  * @retval  void
  */
void FeedForward_Yaw_Pitch()
{
	static float exp1,exp2, exp3, exp4;  // 临时变量
	/* 平衡Pitch重力 */
	/* 从大转角到小转角 y = 0.074 * x ^ 2 -20.9418 * x + 1291.57 */
	exp1 = M6020s_Pitch.realAngle;
	if(Cloud.Target_Pitch > M6020s_Pitch.realAngle + Pitch_Margin)
	{
		arm_mult_f32(&exp1, &exp1, &exp3, 1);
		exp2 = 0.074f;
		arm_mult_f32(&exp3, &exp2, &exp3, 1);
		exp2 = 20.9418f;
		arm_mult_f32(&exp2, &exp1, &exp4, 1);
		arm_sub_f32(&exp3, &exp4, &exp3, 1);
		exp2 = 1291.57f;
		arm_add_f32(&exp3, &exp2, &exp4, 1);
		M6020s_Pitch.outCurrent += 1.125f * exp4;
	}
	/* 从小转角到大转角 y = 0.0065 * x ^ 2 -19.0685 * x + 1225.57 */
	else if(Cloud.Target_Pitch < M6020s_Pitch.realAngle - Pitch_Margin)
	{
		arm_mult_f32(&exp1, &exp1, &exp3, 1);
		exp2 = 0.0065f;
		arm_mult_f32(&exp3, &exp2, &exp3, 1);
		exp2 = 19.0685f;
		arm_mult_f32(&exp2, &exp1, &exp4, 1);
		arm_sub_f32(&exp3, &exp4, &exp3, 1);
		exp2 = 1225.57f;
		arm_add_f32(&exp3, &exp2, &exp4, 1);
		M6020s_Pitch.outCurrent += exp4;
	}
	else M6020s_Pitch.outCurrent += 1.125f * exp4;
	
	/* 平衡Yaw摩擦力 */
	
}

#elif Pitch_Fitting == 3
/**
  * @brief   给云台的两个电机发送前馈，pitch用三角函数拟合
  * @param   云台和云台电机的外部接口
  * @retval  void
  */
void FeedForward_Yaw_Pitch()
{
	static float exp1,exp2, exp3, exp4;  // 临时变量
	/* 平衡Pitch重力 */
	/* 从大转角到小转角 y = 2309*sin(0.002941x + 0.5701)弧度 */
	exp1 = M6020s_Pitch.realAngle;
	if(Cloud.Target_Pitch > M6020s_Pitch.realAngle + Pitch_Margin)
	{
		exp2 = 0.002941f;
		arm_mult_f32(&exp1, &exp2, &exp3, 1);
		exp2 = 0.5701;
		arm_add_f32(&exp2, &exp3, &exp4, 1);
		exp3 = arm_sin_f32(exp4);
		exp2 = 2309.0f;
		arm_mult_f32(&exp2, &exp3, &exp1, 1);
	}
	/* 从小转角到大转角 y = 2273*sin(0.002863x + 0.5133)弧度 */
	else if(Cloud.Target_Pitch < M6020s_Pitch.realAngle - Pitch_Margin)
	{
		exp2 = 0.002941f;
		arm_mult_f32(&exp1, &exp2, &exp3, 1);
		exp2 = 0.5701;
		arm_add_f32(&exp2, &exp3, &exp4, 1);
		exp3 = arm_sin_f32(exp4);
		exp2 = 2309.0f;
		arm_mult_f32(&exp2, &exp3, &exp1, 1);
	}
	else M6020s_Pitch.outCurrent += exp4; //确定前馈的比例，一般只取拟合值的百分之八十
	
	/* 平衡Yaw摩擦力 */
	
}

#endif
